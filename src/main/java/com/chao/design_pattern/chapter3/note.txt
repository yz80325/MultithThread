并发编程中3个比较重要的概念：
1.原子性：保证一个操作或者个多个操作，要么都成功，要么都失败，中间不能由于任何的因素中断
2.可见性：一个变量被更新，其它访问这个变量的线程应该得到更新后的变量值（最新变量）
3.有序性：操作按照一定的顺序执行



Java如何保证上面3种特性的：
1.原子性：对基本数据类型的变量读取和赋值是保证了原子性的，要么都成功，要么都失败，这些操作不可被中断
2.可见性（使用volatile关键字保证可见性）：被volatile修饰的变量都应该从主存中读取
3.有序性：（happens-before relationship）
	3.1 代码的执行顺序，编写在前面的发生在编写的后面
	3.2 unlock必须发生在lock之后
	3.3 volatile修饰的变量，对该变量的写操作必须发生在该变量的读操作之前
	3.4 传递规则：操作A先于B，B先于C，那么A肯定先于C
	3.5 线程启动规则：start()方法肯定先于线程run()方法
	3.6 线程中断规则：interrupt这个动作，必须发生在捕获该动作之前
	3.7 对象销毁规则：初始化必须发生在finalize之前
	3.8 线程终结规则：所有的操作都发生在线程死亡之前

volatile关键字
一旦一个共享变量被volatile修饰，具备两层语义
1.保证了不同线程间的可见性
2.禁止对其进行重排序，也就是保证了有序性
3.并为保证原子性

保证重排序的是不会把后面的指令放到屏障的前面，也不会把前面的放到后面
强制对缓存的修改操作立即写入主存
如果是写操作，它会导致其他CPU中的缓存失效（其他线程中的缓存失效）

volatile的使用场景
1.状态量标记
volatile boolean start = true;
while(start){
	// ...
}

void close(){
	start = false;
}

2.保证屏障前后的一致性
volatile boolean init;

------Thread -1--------

obj = careateObje();   1.
init = true;           2.    <----屏障

------Thread -2--------
while(!init){
	sleep();
}

useTheObj();
------  End  ----------

















